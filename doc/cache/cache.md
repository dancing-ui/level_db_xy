# mutable关键字
- mutable 只能用来修饰类的数据成员；而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。
- 什么情况下，需要在const成员函数中修改成员变量呢？
  - 那就是std::mutex，为了保证线程安全，需要修改std::mutex的状态为开锁和解锁，所以当需要在const成员函数中使用std::mutex保证线程安全时，需要将std::mutex声明为mutable

# LRUHandle::key_data[1]
该数组称为“柔性数组”，由C99标准引入，其目的在于声明一个可变长的数组，且柔性数组必须是最后一个成员。
所谓“柔性数组”就是指可变长的数组，既具备链表灵活扩展的能力，又具有内存空间连续的优点
特点如下：
1. 柔性数组成员必须定义在结构体里面且为最后元素；
2. 结构体中不能单独只有柔性数组成员；
3. 柔性数组不占内存。

在一个结构体的最后，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为 0 的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量，数组名这个符号本身代表了一个不可修改的地址常量，

但对于这个数组的大小，我们可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！

注意：这里的数组大小虽然为1，但是我们并不会使用，在申请空间的时候会减去这段长度！！！

柔性数组解决指针存在的问题：
1. 柔性数组地址连续。
2. 在数据拷贝时，结构体使用指针时，必须拷贝它指向的内存，内存不连续会存在问题，柔性数组可以直接拷贝。
3. 减少内存碎片，由于结构体的柔性数组和结构体成员的地址是连续的，即可一同申请内存，因此更大程度地避免了内存碎片。另外由于该成员本身不占结构体空间，因此，整体而言，比普通的数组成员占用空间要会稍微小点。

缺点：
1. 对结构体格式有要求，必须放在最后，作为最后一个成员变量

# in_cache字段
作用：in_cache为真，表示handle在哈希表中，否则不在哈希表中。

背景：用户可能会插入相同的key，指向不同的value，这种情况下，前一次插入的value应该被新的value替换，但如果还有外部引用，就不能将其释放，这种情况下，就会出现哈希表中没有，但仍然没有被释放的 handle。当外部引用释放这个handle时，才会真正调用deleter将其资源释放。in_cache为真时，handle总能在哈希表中找到，总能在in_use_或lru_中找到；如果in_cache为假，无论在哈希表中还是链表中都没有它。

# LRUCache讲解
https://bean-li.github.io/leveldb-LRUCache/

https://quant67.com/post/db/leveldb/lru-cache.html

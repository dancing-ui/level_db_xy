# [Manifest File](https://leveldb-handbook.readthedocs.io/zh/latest/version.html)
manifest文件专用于记录版本信息。leveldb采用了增量式的存储方式，记录每一个版本相较于上一个版本的变化情况。

展开来说，一个Manifest文件中，包含了多条Session Record。一个Session Record记录了从上一个版本至该版本的变化情况。

# O_CLOEXEC
O_CLOEXEC是一个文件描述符标志，用于在打开文件时设置一个称为"close-on-exec"的标志位。这个标志位告诉操作系统，在执行exec函数时关闭文件描述符，以防止被子进程继承。

在Unix系统中，当一个进程调用exec函数时，它会将自己的内存映像替换为一个新的程序的内存映像，从而启动一个新的程序。如果在调用exec函数之前打开了文件描述符，那么这些文件描述符默认会被新程序继承。在某些情况下，这可能会导致安全漏洞或意外的行为，特别是对于安全性敏感的程序。

因此，通过在打开文件时设置O_CLOEXEC标志，可以确保在调用exec函数时自动关闭文件描述符，从而防止它们被继承到新的程序中。这有助于提高程序的安全性和可靠性。

# Limiter
可以帮助类限制资源的使用，避免耗尽。

```C++
private:
  // 可用资源的个数
  // std::atomic互斥的原子操作
  std::atomic<int> acquires_allowed_;

// 构造函数 传入并初始化acquires_allowed_
Limiter(int max_acquires);
// 请求资源
// 如果分配资源--后，资源个数大于0，返回true
// 否则还回资源++，返回false
bool Acquire();
// 释放资源++
void Release();
```

# mmap函数
内存映射：简而言之就是：将内核空间的一段内存区域映射到用户空间。映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，相反，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间与用户空间两者之间需要大量数据传输等操作的话效率是非常高的。当然，也可以将内核空间的一段内存区域同时映射到多个进程，这样还可以实现进程间的共享内存通信。

系统调用mmap()就是用来实现上面说的内存映射。最常见的操作就是文件（在Linux下设备也被看做文件）的操作，可以将某文件映射至内存(进程空间)，如此可以把对文件的操作转为对内存的操作，以此避免更多的lseek()与read(). write()操作，这点对于大文件或者频繁访问的文件而言尤其受益。

mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。unmap执行相反的操作，删除特定地址区域的对象映射。

当使用mmap映射文件到进程后，就可以直接操作这段虚拟地址进行文件的读写等操作，不必再调用read，write等系统调用。但需注意，直接对该段内存写时不会写入超过当前文件大小的内容。

采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。

## 关于常规文件读写时，共享内存的优势
首先简单的回顾一下常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：
1. 进程发起读文件请求。
2. 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。
3. inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。
4. 如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。

对于常规文件系统操作，则需要在内核和用户空间进行2次的数据拷贝（重点！！！）：
1. 从磁盘到内核缓冲区的拷贝：当应用程序调用read()函数读取文件时，操作系统会从磁盘读取文件的数据，并将数据复制到内核缓冲区中。这个过程涉及一次数据的拷贝，从磁盘到内核缓冲区。
2. 从内核缓冲区到用户空间的拷贝：一旦数据被读取到内核缓冲区中，操作系统需要将数据从内核缓冲区复制到应用程序的用户空间缓冲区中。这个过程涉及一次数据的拷贝，从内核缓冲区到用户空间。

而共享内存最多只拷贝1次数据甚至零拷贝（重点！！！）：
1. 零次数据拷贝：当文件的数据页已经在内存中存在并且已被缓存时，mmap()不会导致数据的拷贝。这时候，文件数据已经在内核页缓存中，因此不需要进行额外的拷贝操作。
2. 一次数据拷贝：当文件的数据页尚未在内存中，并且需要从磁盘加载到内存中时，mmap()可能会导致一次数据的拷贝。在这种情况下，操作系统会从磁盘读取文件的数据，并将其拷贝到内存中。

总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。
## 关于进程间通信时，共享内存的优势

对于像管道和消息队列等通信方式，则需要在内核和用户空间进行4次的数据拷贝：
1. 用户缓冲区到内核缓冲区
2. 内核缓冲区到管道缓冲区
3. 管道缓冲区到内核缓冲区
4. 内核缓冲区到用户缓冲区

而共享内存则只拷贝2次数据：
1. 用户缓冲区到共享内存
2. 共享内存到用户缓冲区

实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。

通常使用mmap()的三种情况： 
1. 提高I/O效率
2. 匿名内存映射
3. 共享内存进程通信

用户空间mmap()函数void *mmap(void *start, size_t length, int prot, int flags,int fd, off_t offset)，下面就其参数解释如下：

- start：用户进程中要映射的用户空间的起始地址，通常为NULL（由内核来指定）
- length：要映射的内存区域的大小
  - 该大小
- prot：期望的内存保护标志
- flags：指定映射对象的类型
- fd：文件描述符（由open函数返回）
- offset：设置在内核空间中已经分配好的的内存区域中的偏移，例如文件的偏移量，大小为PAGE_SIZE的整数倍
- 返回值：mmap()返回被映射区的指针，该指针就是需要映射的内核空间在用户空间的虚拟地址

## mmap()用于共享内存的两种方式
1. 使用普通文件提供的内存映射：适用于任何进程之间；此时，需要打开或创建一个文件，然后再调用mmap()；典型调用代码如下：
```C++
view plainprint?
fd=open(name, flag, mode);   
if(fd<0)   
   ...   
ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 
close(fd); //mmap函数调用成功之后，可以关闭文件，对ptr的读写相当于是对文件的读写
```
2. 使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。 对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可.



[参考链接](https://nieyong.github.io/wiki_cpu/mmap%E8%AF%A6%E8%A7%A3.html)

# unlink
unlink()函数功能即为删除文件。执行unlink()函数会删除所给参数指定的文件。

注意：
执行unlink()函数并不一定会真正的删除文件，它先会检查文件系统中此文件的连接数是否为1，如果不是1说明此文件还有其他链接对象，因此只对此文件的连接数进行减1操作。若连接数为1，并且在此时没有任何进程打开该文件，此内容才会真正地被删除掉。在有进程打开此文件的情况下，则暂时不会删除，直到所有打开该文件的进程都结束时文件就会被删除。

返回值：成功返回0，失败返回 -1

# std::aligned_storage

std::aligned_storage是C++标准库提供的一个模板类，用于在编译时创建一块原始存储区域，该存储区域的大小和对齐方式由用户指定。

std::aligned_storage通常用于需要在编译时动态分配内存空间，但是又需要确保所分配内存的大小和对齐方式满足特定需求的情况。例如，当需要实现自定义的内存池、缓冲区或数据结构时，可以使用std::aligned_storage来分配内存，并确保内存的大小和对齐方式符合要求。

使用std::aligned_storage时，可以通过std::aligned_storage::type成员来获取所分配存储区域的类型。可以使用std::aligned_storage::type来创建对象（placement new），确保对象在内存中的大小和对齐方式满足特定需求。
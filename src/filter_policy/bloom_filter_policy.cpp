#include "filter_policy.h"
#include "hash.h"

namespace ns_filter_policy {

namespace {
static uint32_t BloomHash(ns_data_structure::Slice const &key) {
    return ns_util::Hash(key.data(), key.size(), 0xbc9f1d34);
}
}

class BloomFilterPolicy : public FilterPolicy {
public:
    explicit BloomFilterPolicy(int32_t bits_per_key) :
        bits_per_key_(bits_per_key) {
        // We intentionally round down to reduce probing cost a little bit
        k_ = static_cast<uint64_t>(bits_per_key * 0.69); // 0.69 =~ ln(2)
        if (k_ < 1) k_ = 1;
        if (k_ > 30) k_ = 30;
    }
    char const *Name() const override {
        return "leveldb.BuiltinBloomFilter2";
    }

    void CreateFilter(ns_data_structure::Slice const *keys, int32_t n, std::string *dst) const override {
        // Compute bloom filter size (in both bits and bytes)
        uint64_t bits = n * bits_per_key_;
        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;

        uint64_t bytes = (bits + 7) / 8;
        bits = bytes * 8;
        uint64_t const init_size = dst->size();
        dst->resize(init_size + bytes, 0);
        dst->push_back(static_cast<char>(k_)); // Remember # of probes in filter！！！
        char *array = &(*dst)[init_size];
        for (int32_t i = 0; i < n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            uint32_t h = BloomHash(keys[i]);
            uint32_t const delta = (h >> 17) | (h << 15); // Rotate right 17 bits
            for (uint64_t j = 0; j < k_; j++) {
                uint32_t const bitpos = h % bits;
                array[bitpos / 8] |= (1 << (bitpos % 8));
                h += delta;
            }
        }
    }

    bool KeyMayMatch(ns_data_structure::Slice const &key, ns_data_structure::Slice const &bloom_filter) const override {
        uint64_t const len = bloom_filter.size();
        if (len < 2) return false;
        uint8_t const *array = bloom_filter.data();
        uint64_t const bits = (len - 1) * 8;
        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        uint64_t const k = array[len - 1];
        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }
        uint32_t h = BloomHash(key);
        uint32_t const delta = (h >> 17) | (h << 15); // Rotate right 17 bits
        for (uint64_t j = 0; j < k; j++) {
            uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0) return false;
            h += delta;
        }
        return true;
    }

private:
    uint64_t bits_per_key_;
    uint64_t k_;
};

FilterPolicy const *NewBloomFilterPolicy(int32_t bits_per_key) {
    return new BloomFilterPolicy(bits_per_key);
}

} // ns_filter_policy